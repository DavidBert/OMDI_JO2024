{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"INSA 4A Outils et m\u00e9thodes de d\u00e9veloppement informatique Projet : Site Web Interactif pour les Jeux Olympiques de Paris 2024 Le Comit\u00e9 d'Organisation des Jeux Olympiques de Paris 2024 souhaite d\u00e9velopper une plateforme web interactive pour les Jeux Olympiques de Paris 2024. Vous avez \u00e9t\u00e9 mandat\u00e9s pour d\u00e9velopper cette plateforme fournissant des informations essentielles aux touristes et aux passionn\u00e9s des Jeux Olympiques, am\u00e9liorant ainsi leur exp\u00e9rience globale. Cahier des charges 1. Dashboard des M\u00e9dailles Cr\u00e9er un tableau de bord r\u00e9capitulatif des m\u00e9dailles par pays. Proposer des visualisations cr\u00e9atives (ex : carte interactive, graphiques dynamiques). 2. Recherche d'Athl\u00e8tes Impl\u00e9menter un formulaire de recherche avanc\u00e9e permettant de filtrer les athl\u00e8tes selon divers crit\u00e8res : Nom Nationalit\u00e9 Discipline si disponible Afficher les m\u00e9dailles obtenues par l'athl\u00e8te, le cas \u00e9ch\u00e9ant. 3. Carte Interactive des Sites Olympiques D\u00e9velopper une carte interactive montrant tous les sites des comp\u00e9titions. Permettre aux utilisateurs de cliquer sur chaque site pour voir : Les \u00e9preuves qui s'y d\u00e9roulent Les horaires des comp\u00e9titions Les athl\u00e8tes participants 4. Agenda Interactif des \u00c9preuves Cr\u00e9er un calendrier dynamique des \u00e9preuves. Inclure des filtres par sport, date, et lieu. 5. Parcours de la Flamme Olympique Visualiser le trajet de la flamme olympique sur une carte interactive. 6. Guide Gastronomique Int\u00e9grer une fonctionnalit\u00e9 pour afficher les restaurants les plus proches des sites olympiques \u00e0 Paris lorsqu'on les s\u00e9l\u00e9ctionne. Utiliser le dataset des 200 meilleurs restaurants parisiens de TripAdvisor. 7. Syst\u00e8me de FAQ Intelligent Dans un second temps, le comit\u00e9 olympique vous demandera de d\u00e9velopper un outil de recherche intelligent pour les questions fr\u00e9quemment pos\u00e9es. - D\u00e9velopper un outil de recherche intelligent pour les questions fr\u00e9quemment pos\u00e9es. - Utiliser le machine learning pour : - D\u00e9tecter les doublons de questions - Proposer les 3 questions les plus similaires \u00e0 une requ\u00eate donn\u00e9e - optionnel: Int\u00e9grer un syst\u00e8me de feedback pour am\u00e9liorer continuellement les r\u00e9ponses. Sp\u00e9cifications Techniques Donn\u00e9es Pour ce projet, le comit\u00e9 olympique vous conseille d'utiliser les datasets suivants: - Dataset principal des Jeux Olympiques de Paris 2024 - Parcours de la flamme olympique - 200 meilleurs restaurants parisiens selon TripAdvisor Framework Web Pas de contrainte particuli\u00e8re, vous pouvez utiliser le framework de votre choix. Si vous souhaitez faire le projet en Python, le comit\u00e9 olympique vous conseille d'utiliser Flask comme framework web principal. - Flask est l\u00e9ger et flexible, id\u00e9al pour ce type de projet \u00e9ducatif. - Il permet une int\u00e9gration facile avec diverses biblioth\u00e8ques de visualisation. Gestion des Donn\u00e9es Le comit\u00e9 olympique vous conseille d'utiliser python pour la manipulation et l'analyse des donn\u00e9es CSV. - Utiliser pandas pour la manipulation et l'analyse des donn\u00e9es CSV. - Pandas est parfaitement adapt\u00e9 pour travailler avec des fichiers CSV fournis. - Il offre des fonctionnalit\u00e9s puissantes pour le filtrage, le tri et l'agr\u00e9gation des donn\u00e9es. Visualisation Employer Plotly pour cr\u00e9er des graphiques interactifs (ex : dashboard des m\u00e9dailles). Utiliser Folium pour les cartes interactives (parcours de la flamme olympique, sites des comp\u00e9titions). Interface Utilisateur La encore vous pouvez utiliser le framework de votre choix. Pour ceux qui souhaitent faire le projet en Python, le comit\u00e9 olympique vous conseille d'utiliser Streamlit pour le d\u00e9veloppement rapide de l'interface utilisateur. - Streamlit est particuli\u00e8rement adapt\u00e9 pour cr\u00e9er des applications de data science interactives avec peu de code. - Il s'int\u00e8gre bien avec pandas, Plotly et Folium. Machine Learning Utiliser scikit-learn pour les t\u00e2ches de base en ML, comme la vectorisation de texte et les mesures de similarit\u00e9. Employer des biblioth\u00e8ques comme NLTK ou spaCy pour le traitement du langage naturel (NLP) n\u00e9cessaire \u00e0 la FAQ intelligente. Stockage de Donn\u00e9es Stocker les donn\u00e9es dans des fichiers CSV, conform\u00e9ment au format des datasets fournis. optionnel: Si n\u00e9cessaire, utiliser SQLite pour une base de donn\u00e9es l\u00e9g\u00e8re, facile \u00e0 mettre en place sans configuration serveur. DevOps Utiliser Git pour le contr\u00f4le de version. Mettre en place une pipeline CI/CD avec GitLab CI pour l'int\u00e9gration et le d\u00e9ploiement continus. Impl\u00e9menter des tests unitaires avec pytest. optionnel: Utiliser Docker pour la containerisation de l'application si n\u00e9cessaire pour le d\u00e9ploiement. Gestion de Projet Utiliser Jira pour la gestion des t\u00e2ches et le suivi de l'avancement. Mettre en place des sprints Agile de 2 semaines. Organiser des stand-ups quotidiens et des revues de sprint. D\u00e9ploiement Utiliser les serveurs INSA pour le d\u00e9ploiement de l'application web. Livrables Code source complet sur GitLab Un site web h\u00e9berg\u00e9 sur les serveurs INSA Documentation technique et guide utilisateur Rapport de performance du mod\u00e8le de ML pour la FAQ Pr\u00e9sentation finale du projet","title":"Home"},{"location":"#insa-4a-outils-et-methodes-de-developpement-informatique","text":"","title":"INSA 4A Outils et m\u00e9thodes de d\u00e9veloppement informatique"},{"location":"#projet","text":"","title":"Projet :"},{"location":"#site-web-interactif-pour-les-jeux-olympiques-de-paris-2024","text":"Le Comit\u00e9 d'Organisation des Jeux Olympiques de Paris 2024 souhaite d\u00e9velopper une plateforme web interactive pour les Jeux Olympiques de Paris 2024. Vous avez \u00e9t\u00e9 mandat\u00e9s pour d\u00e9velopper cette plateforme fournissant des informations essentielles aux touristes et aux passionn\u00e9s des Jeux Olympiques, am\u00e9liorant ainsi leur exp\u00e9rience globale.","title":"Site Web Interactif pour les Jeux Olympiques de Paris 2024"},{"location":"#cahier-des-charges","text":"","title":"Cahier des charges"},{"location":"#1-dashboard-des-medailles","text":"Cr\u00e9er un tableau de bord r\u00e9capitulatif des m\u00e9dailles par pays. Proposer des visualisations cr\u00e9atives (ex : carte interactive, graphiques dynamiques).","title":"1. Dashboard des M\u00e9dailles"},{"location":"#2-recherche-dathletes","text":"Impl\u00e9menter un formulaire de recherche avanc\u00e9e permettant de filtrer les athl\u00e8tes selon divers crit\u00e8res : Nom Nationalit\u00e9 Discipline si disponible Afficher les m\u00e9dailles obtenues par l'athl\u00e8te, le cas \u00e9ch\u00e9ant.","title":"2. Recherche d'Athl\u00e8tes"},{"location":"#3-carte-interactive-des-sites-olympiques","text":"D\u00e9velopper une carte interactive montrant tous les sites des comp\u00e9titions. Permettre aux utilisateurs de cliquer sur chaque site pour voir : Les \u00e9preuves qui s'y d\u00e9roulent Les horaires des comp\u00e9titions Les athl\u00e8tes participants","title":"3. Carte Interactive des Sites Olympiques"},{"location":"#4-agenda-interactif-des-epreuves","text":"Cr\u00e9er un calendrier dynamique des \u00e9preuves. Inclure des filtres par sport, date, et lieu.","title":"4. Agenda Interactif des \u00c9preuves"},{"location":"#5-parcours-de-la-flamme-olympique","text":"Visualiser le trajet de la flamme olympique sur une carte interactive.","title":"5. Parcours de la Flamme Olympique"},{"location":"#6-guide-gastronomique","text":"Int\u00e9grer une fonctionnalit\u00e9 pour afficher les restaurants les plus proches des sites olympiques \u00e0 Paris lorsqu'on les s\u00e9l\u00e9ctionne. Utiliser le dataset des 200 meilleurs restaurants parisiens de TripAdvisor.","title":"6. Guide Gastronomique"},{"location":"#7-systeme-de-faq-intelligent","text":"Dans un second temps, le comit\u00e9 olympique vous demandera de d\u00e9velopper un outil de recherche intelligent pour les questions fr\u00e9quemment pos\u00e9es. - D\u00e9velopper un outil de recherche intelligent pour les questions fr\u00e9quemment pos\u00e9es. - Utiliser le machine learning pour : - D\u00e9tecter les doublons de questions - Proposer les 3 questions les plus similaires \u00e0 une requ\u00eate donn\u00e9e - optionnel: Int\u00e9grer un syst\u00e8me de feedback pour am\u00e9liorer continuellement les r\u00e9ponses.","title":"7. Syst\u00e8me de FAQ Intelligent"},{"location":"#specifications-techniques","text":"","title":"Sp\u00e9cifications Techniques"},{"location":"#donnees","text":"Pour ce projet, le comit\u00e9 olympique vous conseille d'utiliser les datasets suivants: - Dataset principal des Jeux Olympiques de Paris 2024 - Parcours de la flamme olympique - 200 meilleurs restaurants parisiens selon TripAdvisor","title":"Donn\u00e9es"},{"location":"#framework-web","text":"Pas de contrainte particuli\u00e8re, vous pouvez utiliser le framework de votre choix. Si vous souhaitez faire le projet en Python, le comit\u00e9 olympique vous conseille d'utiliser Flask comme framework web principal. - Flask est l\u00e9ger et flexible, id\u00e9al pour ce type de projet \u00e9ducatif. - Il permet une int\u00e9gration facile avec diverses biblioth\u00e8ques de visualisation.","title":"Framework Web"},{"location":"#gestion-des-donnees","text":"Le comit\u00e9 olympique vous conseille d'utiliser python pour la manipulation et l'analyse des donn\u00e9es CSV. - Utiliser pandas pour la manipulation et l'analyse des donn\u00e9es CSV. - Pandas est parfaitement adapt\u00e9 pour travailler avec des fichiers CSV fournis. - Il offre des fonctionnalit\u00e9s puissantes pour le filtrage, le tri et l'agr\u00e9gation des donn\u00e9es.","title":"Gestion des Donn\u00e9es"},{"location":"#visualisation","text":"Employer Plotly pour cr\u00e9er des graphiques interactifs (ex : dashboard des m\u00e9dailles). Utiliser Folium pour les cartes interactives (parcours de la flamme olympique, sites des comp\u00e9titions).","title":"Visualisation"},{"location":"#interface-utilisateur","text":"La encore vous pouvez utiliser le framework de votre choix. Pour ceux qui souhaitent faire le projet en Python, le comit\u00e9 olympique vous conseille d'utiliser Streamlit pour le d\u00e9veloppement rapide de l'interface utilisateur. - Streamlit est particuli\u00e8rement adapt\u00e9 pour cr\u00e9er des applications de data science interactives avec peu de code. - Il s'int\u00e8gre bien avec pandas, Plotly et Folium.","title":"Interface Utilisateur"},{"location":"#machine-learning","text":"Utiliser scikit-learn pour les t\u00e2ches de base en ML, comme la vectorisation de texte et les mesures de similarit\u00e9. Employer des biblioth\u00e8ques comme NLTK ou spaCy pour le traitement du langage naturel (NLP) n\u00e9cessaire \u00e0 la FAQ intelligente.","title":"Machine Learning"},{"location":"#stockage-de-donnees","text":"Stocker les donn\u00e9es dans des fichiers CSV, conform\u00e9ment au format des datasets fournis. optionnel: Si n\u00e9cessaire, utiliser SQLite pour une base de donn\u00e9es l\u00e9g\u00e8re, facile \u00e0 mettre en place sans configuration serveur.","title":"Stockage de Donn\u00e9es"},{"location":"#devops","text":"Utiliser Git pour le contr\u00f4le de version. Mettre en place une pipeline CI/CD avec GitLab CI pour l'int\u00e9gration et le d\u00e9ploiement continus. Impl\u00e9menter des tests unitaires avec pytest. optionnel: Utiliser Docker pour la containerisation de l'application si n\u00e9cessaire pour le d\u00e9ploiement.","title":"DevOps"},{"location":"#gestion-de-projet","text":"Utiliser Jira pour la gestion des t\u00e2ches et le suivi de l'avancement. Mettre en place des sprints Agile de 2 semaines. Organiser des stand-ups quotidiens et des revues de sprint.","title":"Gestion de Projet"},{"location":"#deploiement","text":"Utiliser les serveurs INSA pour le d\u00e9ploiement de l'application web.","title":"D\u00e9ploiement"},{"location":"#livrables","text":"Code source complet sur GitLab Un site web h\u00e9berg\u00e9 sur les serveurs INSA Documentation technique et guide utilisateur Rapport de performance du mod\u00e8le de ML pour la FAQ Pr\u00e9sentation finale du projet","title":"Livrables"},{"location":"Introduction_git/","text":"Introduction to Git, GitLab and CI/CD Introduction: This practical session is designed for small groups of 2-3 people to work through together. It is very important that every member of the group runs the different commands in this practical session all shared with the same repository (we will see later what this means). During this project, you will learn if not already, how to use Git and GitLab to manage your code and to collaborate with your team. You will also learn how to use GitLab Actions to deploy your code and to run tests. This practical session is not a full Git and GitLab course, but rather a practical introduction to these tools providing you with the basic knowledge to be able to use them during this project. If you want to learn more about Git and GitLab, you can refer to the official documentation . Understanding Version Control Version control is a system that helps track and manage changes to files over time. It's an essential tool for software development, enabling developers to collaborate effectively, maintain a history of changes, and manage different versions of their code. With version control, you can revert files to a previous state, compare changes over time, see who last modified something that might be causing issues, and more. It acts as a safety net, allowing developers to experiment with new ideas without fear of losing their original work. Example: Imagine you're working on a Python application for a bookstore. Over time, you add several features, but one of them turns out to be problematic. With version control, you can easily remove just the unwanted feature while keeping the other improvements. Let's see how this might look: Day 1: You start with a basic Book class. class Book: def __init__(self, title, author, price): self.title = title self.author = author self.price = price def display_info(self): return f\"{self.title} by {self.author}: ${self.price}\" Day 3: You add a discount feature. class Book: def __init__(self, title, author, price): self.title = title self.author = author self.price = price def display_info(self): return f\"{self.title} by {self.author}: ${self.price}\" def apply_discount(self, discount): self.price = self.price * (1 - discount) Day 5: You add a feature to track stock, but it has a bug. class Book: def __init__(self, title, author, price, stock): self.title = title self.author = author self.price = price self.stock = stock def display_info(self): return f\"{self.title} by {self.author}: ${self.price} (In stock: {self.stock})\" def apply_discount(self, discount): self.price = self.price * (1 - discount) def update_stock(self, quantity): self.stock += quantity # Bug: This allows negative stock! Day 7: You add a method to calculate total value. class Book: def __init__(self, title, author, price, stock): self.title = title self.author = author self.price = price self.stock = stock def display_info(self): return f\"{self.title} by {self.author}: ${self.price} (In stock: {self.stock})\" def apply_discount(self, discount): self.price = self.price * (1 - discount) def update_stock(self, quantity): self.stock += quantity # Bug: This allows negative stock! def total_value(self): return self.price * self.stock Day 10: You realize the stock tracking feature has a bug allowing negative stock. With version control, you can: 1. Review the history of changes to identify when the bug was introduced. 2. Revert just the problematic update_stock method while keeping the other beneficial changes. 3. Fix the bug and commit the corrected version. The corrected version might look like this: class Book: def __init__(self, title, author, price, stock): self.title = title self.author = author self.price = price self.stock = stock def display_info(self): return f\"{self.title} by {self.author}: ${self.price} (In stock: {self.stock})\" def apply_discount(self, discount): self.price = self.price * (1 - discount) def update_stock(self, quantity): if self.stock + quantity >= 0: self.stock += quantity else: raise ValueError(\"Stock cannot be negative\") def total_value(self): return self.price * self.stock This example demonstrates how version control allows you to: - Track the evolution of your code over time - Identify when and where issues were introduced - Selectively keep or discard changes - Maintain a history of your development process Modern development teams use version control systems to manage their code, track changes, and collaborate effectively. Git is one of the most popular version control systems, providing a robust set of features for managing codebases of all sizes. Git Git is a distributed version control system that has revolutionized how developers manage and track changes in their code. Created by Linus Torvalds in 2005, Git was born out of the need for a fast, efficient, and reliable system to manage the development of the Linux kernel. Unlike centralized version control systems that preceded it, Git allows developers to have a complete copy of the project history on their local machines, enabling offline work and providing a safeguard against data loss. Git's distributed nature facilitates collaboration among developers, allowing them to work on different features simultaneously and merge their changes seamlessly. Its branching and merging capabilities make it easy to experiment with new ideas without affecting the main codebase. Since its inception, Git has become the de facto standard for version control in software development, used by millions of developers and organizations worldwide. Git's Basic Paradigms Snapshots, Not Differences : Unlike other version control systems that store data as changes to a base version of each file, Git thinks of its data more like a series of snapshots of a miniature filesystem. Every time you commit, or save the state of your project in Git, it basically takes a picture of what all your files look like at that moment and stores a reference to that snapshot. Local Operations : Most operations in Git need only local files and resources to operate. This means you can work on your project even when you're offline or not on a VPN, unlike centralized systems that need to communicate with a server for almost every operation. Integrity : Everything in Git is check-summed before it is stored and is then referred to by that checksum. This means it's impossible to change the contents of any file or directory without Git knowing about it. This functionality is built into Git at the lowest levels and is integral to its philosophy. Branching Model : Git's branching model is its \"killer feature.\" Unlike many other VCSs, Git encourages workflows that branch and merge often. This allows for feature branches, experimentation, and parallel development streams that can be easily merged when ready. Distributed Development : In Git, every developer's working copy of the code is also a repository that can contain the full history of all changes. This allows for multiple backup copies and various collaborative development models. Fast and Lightweight : Git is designed to be fast and efficient with large projects. Most operations are local, reducing the overhead of communicating with a centralized server. The Three States in Git In Git, files can exist in three states: Modified : You have changed the file but have not committed it to your database yet. Staged : You have marked a modified file in its current version to go into your next commit snapshot. Committed : The data is safely stored in your local database. These three states correspond to the three main sections of a Git project. When not tracked by Git, a file is in the Untracked state. Git Areas and Workflow Understanding the different areas in Git is crucial for mastering its workflow. Git manages your project's files through four main areas: Working Directory (Working Tree) : This is where you actually work on your project files. It's a single checkout of one version of the project. These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify. Staging Area (Index) : This is a file, generally contained in your Git directory, that stores information about what will go into your next commit. It's sometimes referred to as the \"Index\". Think of it as a prep area for your next commit. Files are added to this area with the git add command. Local Repository : This is where Git stores the metadata and object database for your project. It's what's copied when you clone a repository from another computer. The local repository contains all of your committed changes. It's located in the .git directory of your project. Remote Repository : This is a version of your project that is hosted on the Internet or network somewhere (like GitHub, GitLab, or Bitbucket). You can have several of them, each of which generally is either read-only or read/write for you. Collaborating with others involves managing your remote repositories and pushing and pulling data to and from them when you need to share work. Basic Git Workflow: You modify files in your Working Directory. You stage the files, adding snapshots of them to your Staging Area. You do a commit, which takes the files as they are in the Staging Area and stores that snapshot permanently to your Local Repository. You push your changes to a Remote Repository to share with others or as a backup. Understanding these areas and how they interact is key to understanding Git's workflow and effectively managing your projects with version control. GitLab GitLab is a web-based hosting service for Git repositories. Launched in 2008, it has become the world's largest host of source code and a central hub for collaboration among developers. While Git is a command-line tool, GitLab provides a web-based graphical interface. It also offers access control and several collaboration features, such as bug tracking, feature requests, task management, and wikis for every project. Key features of GitLab include: Repository Hosting : GitLab can host your Git repositories in the cloud, making it easy to share and collaborate on code. Fork and Pull Request : Users can \"fork\" an existing repository (creating their own copy), make changes, and then submit a \"pull request\" to propose those changes back to the original project. Issue Tracking : GitLab provides a system for reporting and managing bugs, feature requests, and other tasks related to a project. Project Management Tools : Including project boards, milestones, and other tools to help manage and organize work on repositories. Social Coding : Users can follow repositories and other users, star repositories they like, and see a feed of activity from repositories and users they're interested in. GitLab Pages : A feature that allows hosting of static websites directly from a GitLab repository. Integrations : GitLab can integrate with many third-party services, enhancing its capabilities for things like continuous integration and deployment. GitLab has played a significant role in the growth of open-source software, providing a platform where developers from around the world can collaborate on projects. It's used not only by individual developers and open-source projects but also by large companies to host and manage their code. Setting up your environment Anaconda and Python: Download and install Anaconda from the official website: https://www.anaconda.com/products/distribution During installation, make sure to add Anaconda to your PATH environment variable when prompted. Open an Anaconda Prompt (on Windows) or a terminal (on macOS/Linux). Create a new environment for this project: conda create --name gitproject python=3.8 Activate the environment: conda activate gitproject Install Flask (we'll use it for examples during the session): pip install flask Git 1. Download Git from the official website: https://git-scm.com/downloads 2. Follow the installation instructions for your operating system. 3. After installation, open a new terminal or command prompt and verify the installation: git --version Configure your Git username and email: git config --global user.name \"Your Name\" git config --global user.email \"your.email@example.com\" GitLab We will use GitLab as our remote repository for this project. A GitLab server is already hosted at INSA, you can access it at https://gitlab-ens.insa-toulouse.fr/ (you need to be connected to the INSA VPN to access it). Verify that you do have a GitLab account. Remote repository (Just one person in the group should do this and invite others to collaborate) Log in to GitLab. Click the create a project button. Name your repository (e.g., \"flask-git-demo\"). Choose to make it public. Initialize the repository with a README file. Click \"Create project\". To invite collaborators: Go to your repository's page. On the left menu, click on \"Members\" and invite the other members of the group. Give them the \"Developer\" role. Local repository Open a terminal or command prompt. Navigate to the directory where you want to create your project: cd path/to/your/project/directory Clone the remote repository: git clone https://GitLab.com/your-username/flask-git-demo.git (Replace 'your-username' with the GitLab username of the person who created the repository) 4. Navigate into the cloned repository: cd flask-git-demo Now your environment is set up and ready for the Git and GitLab practical session. Each member of the group should have Python, Flask, and Git installed, a GitLab account, and a local copy of the repository. The repository owner has set up the remote repository and invited other group members as collaborators. Practical session: A Flask Web App Development with Git and GitLab We'll build a Flask web app that collects a user's name and date of birth, then displays various information based on this input. We'll develop this app in stages, using Git and GitLab to manage our development process. Stage 1: Basic Setup and First Commit - Explained Guide In this stage, we'll set up a basic Flask app within our existing Git repository. To avoid conflicts, only one person (the team lead) should perform the initial setup and push the changes. Other team members will then pull these changes. For the Team Lead: 1. Navigate to the Project Directory First, we need to ensure we're in the correct directory for our project. cd path/to/flask-git-demo This command changes the current directory to your project folder. 2. Create the Flask App Now, we'll create the basic structure for our Flask application. Create a new file called app.py : touch app.py # touch is a command that creates an empty file # on windows just create it manually This command creates an empty file named app.py . Open app.py in your preferred text editor and add the following code: from flask import Flask, render_template, request from datetime import datetime app = Flask(__name__) @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] welcome_message = f\"Welcome, {name}! Your date of birth is {dob}.\" return render_template('result.html', message=welcome_message) return render_template('index.html') if __name__ == '__main__': app.run(debug=True) This code sets up a basic Flask app with a route that handles both GET and POST requests. Create a new directory for our HTML templates: mkdir templates # mkdir is a command that creates a new directory # on windows just create it manually This command creates a new directory named \"templates\", where Flask will look for our HTML files. Create two HTML files in the templates directory: For index.html : touch templates/index.html # on windows just create it manually Then add the HTML content for the form in your text editor. <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Birthday App</title> <link rel=\"stylesheet\" href=\"{{ url_for('static', filename='style.css') }}\"> </head> <body> <h1>Welcome to the Birthday App</h1> <form method=\"POST\"> <label for=\"name\">Name:</label> <input type=\"text\" id=\"name\" name=\"name\" required> <label for=\"dob\">Date of Birth:</label> <input type=\"date\" id=\"dob\" name=\"dob\" required> <input type=\"submit\" value=\"Submit\"> </form> </body> </html> For result.html : touch templates/result.html # on windows just create it manually Then add the HTML content for the result page in your text editor. <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Birthday App Result</title> <link rel=\"stylesheet\" href=\"{{ url_for('static', filename='style.css') }}\"> </head> <body> <h1>Your Birthday Information</h1> <p>{{ message }}</p> <a href=\"{{ url_for('index') }}\">Go back</a> </body> </html> 3. Update .gitignore To keep our repository clean, we'll update the .gitignore file to exclude unnecessary files. echo \"venv/\" >> .gitignore echo \"__pycache__/\" >> .gitignore echo \"*.pyc\" >> .gitignore These commands append new lines to the .gitignore file, telling Git to ignore the virtual environment directory, Python cache files, and compiled Python files. By adding these files to the .gitignore file, we ensure that they are not tracked by Git, meaning they won't be committed to the repository. 4. Git Operations Now we'll use Git to track our new files and push them to the remote repository. Check the status of your repository: git status This command shows you which files have been changed or are untracked. Add the new files to the staging area: git add . This stages all new and modified files, preparing them for commit. Check the status again to verify that the files have been staged: git status Commit the changes: git commit -m \"Add basic Flask app structure\" This creates a new commit with the staged changes and adds a descriptive message. Check the status again to verify that the commit has been created: git status Push the changes to the remote repository: git push origin main This uploads your local commits to the remote repository on GitLab. Check the status again to verify that the commit has been pushed: git status 5. Testing the App Before notifying your team, make sure the app works as expected: python app.py This command runs your Flask application. Open a web browser and go to http://127.0.0.1:5000/ to verify the app is functioning correctly. 6. Notify Team Members Once you've successfully pushed the changes and tested the app, notify your team members that the initial setup is complete and they can proceed with their steps. For Other Team Members: After the team lead has completed the setup and pushed the changes, follow these steps: Pull the latest changes from the remote repository: git pull origin main This command fetches the latest changes from the remote repository and merges them into your local branch. Test the app to ensure it's working on your local machine: python app.py This runs the Flask application. Check http://127.0.0.1:5000/ in your browser to verify it's working correctly. Collaboration Notes Always pull the latest changes before starting work each day: git pull origin main This ensures you're working with the most up-to-date version of the project. If you encounter any issues or merge conflicts, communicate with your team to resolve them. Remember to commit your changes frequently with meaningful commit messages as you start working on new features in the upcoming stages. In the next stages, we'll add more features to this app and explore more Git and GitLab concepts as a team. Stage 2: Implementing Age Calculation - Direct Implementation In this stage, we'll add a feature to calculate the user's age based on their date of birth. We'll implement this directly on the main branch to practice basic Git workflows. For the Student Lead of Stage 2: 1. Prepare Your Local Repository Ensure your local repository is up-to-date: git pull origin main This fetches and merges the latest changes from the main branch. 2. Implement Age Calculation Open app.py and add a new function to calculate age: from datetime import datetime def calculate_age(dob): today = datetime.today() birth_date = datetime.strptime(dob, \"%Y-%m-%d\") age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day)) return age Modify the index function to use this new calculation: @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] age = calculate_age(dob) welcome_message = f\"Welcome, {name}! You are {age} years old.\" return render_template('result.html', message=welcome_message) return render_template('index.html') 3. Test Your Changes Run the Flask application to test your changes: python app.py Verify that the age calculation works correctly by submitting the form and checking the result. 4. Commit Your Changes After confirming that everything works: git add app.py git commit -m \"Add age calculation feature\" This stages and commits your changes to your local main branch. 5. Push Your Changes Push your commits to the remote repository: git push origin main This updates the main branch on GitLab with your new changes. 6. Notify Team Members Let your team know that you've pushed new changes to the main branch. For Other Team Members: After the student lead has pushed the changes: Pull the latest changes from the remote repository: git pull origin main This updates your local main branch with the new changes. Test the updated application to ensure everything works correctly: python app.py If you encounter any issues, communicate with the team to resolve them. Stage 3: Adding Zodiac Sign Feature - Branching and Pull Requests Now that we've implemented a feature directly on the main branch, let's discuss the concept of branching and why it's useful: Branching in Git allows developers to diverge from the main line of development and work independently on features or experiments without affecting the main codebase. This has several advantages: Isolation : You can work on different features or experiments without interfering with the main codebase or other developers' work. Easier collaboration : Multiple developers can work on different features simultaneously without conflicts. Code review : Branches facilitate code reviews through pull requests before merging changes into the main codebase. Experimentation : You can try out ideas without the risk of breaking the main codebase. In this stage, we'll add a feature to determine the user's zodiac sign based on their date of birth. We'll use Git branching and create a pull request to implement this feature, demonstrating a more advanced Git workflow. For the Student Lead of Stage 3: 1. Ensure Your Repository is Up-to-Date First, make sure you're on the main branch and it's up-to-date: git checkout main git pull origin main 2. Create a New Branch Create and switch to a new branch for the zodiac sign feature: git checkout -b feature/zodiac-sign 3. Implement the Zodiac Sign Feature In app.py , add a new function to determine the zodiac sign: def get_zodiac_sign(dob): month, day = map(int, dob.split('-')[1:]) zodiac_signs = [ (1, 20, \"Capricorn\"), (2, 19, \"Aquarius\"), (3, 20, \"Pisces\"), (4, 20, \"Aries\"), (5, 21, \"Taurus\"), (6, 21, \"Gemini\"), (7, 22, \"Cancer\"), (8, 23, \"Leo\"), (9, 23, \"Virgo\"), (10, 23, \"Libra\"), (11, 22, \"Scorpio\"), (12, 22, \"Sagittarius\"), (12, 31, \"Capricorn\") ] for m, d, sign in zodiac_signs: if (month, day) <= (m, d): return sign Modify the index function to include the zodiac sign: @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] age = calculate_age(dob) zodiac = get_zodiac_sign(dob) message = f\"Welcome, {name}! You are {age} years old. Your zodiac sign is {zodiac}.\" return render_template('result.html', message=message) return render_template('index.html') 4. Test Your Changes Run the Flask application and test the new feature: python app.py 5. Commit Your Changes After ensuring everything works: git add app.py git commit -m \"Add zodiac sign feature\" 6. Push Your Branch to GitLab Push your feature branch to the remote repository: git push -u origin feature/zodiac-sign 7. Create a Pull Request Go to your repository on GitLab. You should see a prompt to create a merge request for your recently pushed branch. Click on it. Fill in the details of your merge request, describing the new zodiac sign feature. Assign team members to review your merge request. For Other Team Members (Reviewers): Reviewing the Pull Request Go to the repository on GitLab and navigate to the \"Merge requests\" tab on the left menu. Click on the merge request for the zodiac sign feature. Review the changes: Check the code for correctness and style. Consider how this feature integrates with the existing codebase. To test the changes locally: git fetch origin # to update the local repository with the latest changes from the remote repository git checkout feature/zodiac-sign # to switch to the feature branch python app.py # to test the changes locally Leave comments or request changes if necessary. If everything looks good, approve the pull request. After the Pull Request is Merged Once the pull request is approved and merged: Switch back to the main branch: git checkout main Pull the latest changes: git pull origin main Test the updated application to ensure everything works correctly. In the next stage, we'll continue to build on our app and explore more advanced Git and GitLab features, such as handling merge conflicts. Stage 4: Enhancing the UI - Git Stash and GitLab Issues In this stage, we'll improve the user interface of our Flask application by adding some basic CSS. We'll also learn about Git stash for managing temporary changes and use GitLab Issues for task tracking. For the Project Manager (can be any team member): 1. Create GitLab Issues Go to your GitLab repository and navigate to the \"Issues\" tab. Create a new issue titled \"Enhance UI with CSS\". In the description, outline the following tasks: Add a CSS file for styling Style the form on the index page Improve the layout of the result page Add labels like \"enhancement\" and \"ui\". Assign the issue to a team member. For the Assigned Team Member: 1. Set Up Your Work Environment Ensure your local repository is up-to-date: git checkout main git pull origin main 2. Create a New Branch Create a branch for the UI enhancements: git checkout -b feature/ui-enhancement 3. Add CSS File Create a new directory named static in your project root: mkdir static Create a new CSS file: touch static/style.css Add some basic CSS to style.css : body { font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; background-color: #f4f4f4; } h1 { color: #333; } form { background-color: #fff; padding: 20px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.1); } input[type=\"text\"], input[type=\"date\"] { width: 100%; padding: 8px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 4px; } input[type=\"submit\"] { background-color: #333; color: #fff; border: none; padding: 10px 20px; cursor: pointer; border-radius: 4px; } input[type=\"submit\"]:hover { background-color: #555; } 4. Test Your Changes Run the Flask application and verify the UI improvements: python app.py 5. Demonstrate Git Stash Let's say you notice a small bug in the age calculation while working on the UI. Here's how to use Git stash: Make a small change in app.py to fix the bug. Instead of committing this change, use Git stash: git stash save \"Fix age calculation bug\" Your working directory is now clean and back to the state of the last commit. To apply the stashed changes later: git stash pop 6. Commit UI Changes Now, commit your UI enhancements: git add static/style.css templates/index.html templates/result.html git commit -m \"Enhance UI with CSS styling\" 7. Push and Create Pull Request Push your branch and create a merge request: git push -u origin feature/ui-enhancement Create a pull request on GitLab, referencing the issue number in the description (e.g., \"Closes #1\"). For Reviewers: Review the pull request, checking both the code and the visual changes. Test the changes locally if necessary. Provide feedback or approve the changes. After Merging: Close the GitLab issue once the pull request is merged. All team members should pull the latest changes: git checkout main git pull origin main Discuss as a team: 1. How did using GitLab Issues help in organizing the task? 2. What was your experience with Git stash? How might it be useful in other scenarios? 3. How has the workflow evolved from the earlier stages of the project? In the next stage, we'll implement a more complex feature and explore handling merge conflicts. Stage 5: Merging and Rebasing with Conflicts Git offers two primary ways to integrate changes from one branch into another: merging and rebasing. Merge Merging creates a new commit that combines the tips of two branches. This method preserves the entire history of both branches, providing a non-destructive operation that maintains a clear record of when branches diverged and were integrated. The resulting history shows the parallel development that occurred, with a visible branching structure. Merging is particularly safe for shared branches as it doesn't rewrite history. However, in projects with frequent merges, this can lead to a more complex history that may be harder to follow. Rebase Rebasing, on the other hand, moves the entire feature branch to begin on the tip of the main branch, effectively replaying your work on top of it. This results in a linear project history, as if the work was done sequentially rather than in parallel. Rebasing creates a cleaner, more streamlined history which can make it easier to track features. However, it achieves this by rewriting the project history, which can be problematic if the rebased branch has been shared with others. As such, rebasing requires more care when used on public or shared branches. The choice between merging and rebasing often depends on the specific needs of your project and team. Merging is generally preferred for preserving complete history and for work on public branches, while rebasing is often used to maintain a cleaner history, especially for local branches or before merging a feature branch into the main line of development. In this stage, we'll practice merging and rebasing, including handling conflicts. We'll do this by creating a new feature branch, making changes to the main branch, and then exploring both merge and rebase workflows. Part 1: Merging with Conflicts For Developer A: Ensure your main branch is up-to-date: git checkout main git pull origin main Create a new branch for a feature: git checkout -b feature/birthday-countdown Implement the birthday countdown feature in app.py : from datetime import datetime, date def days_to_birthday(dob): today = date.today() dob = datetime.strptime(dob, \"%Y-%m-%d\").date() next_birthday = date(today.year, dob.month, dob.day) if next_birthday < today: next_birthday = date(today.year + 1, dob.month, dob.day) return (next_birthday - today).days @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] age = calculate_age(dob) zodiac = get_zodiac_sign(dob) days_to_bday = days_to_birthday(dob) message = f\"Welcome, {name}! You are {age} years old. Your zodiac sign is {zodiac}. There are {days_to_bday} days until your next birthday!\" return render_template('result.html', message=message) return render_template('index.html') Commit your changes: git add app.py git commit -m \"Add birthday countdown feature\" For Developer B: Make sure you're on the main branch and it's up-to-date: git checkout main git pull origin main Make a change to the index function in app.py : @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] age = calculate_age(dob) zodiac = get_zodiac_sign(dob) message = f\"Hello, {name}! Your age is {age} and your zodiac sign is {zodiac}.\" return render_template('result.html', message=message) return render_template('index.html') Commit and push this change: git add app.py git commit -m \"Update welcome message format\" git push origin main Back to Developer A: Try to merge the main branch into your feature branch: git checkout feature/birthday-countdown git merge main You'll encounter a merge conflict. Open app.py and you'll see something like: <<<<<<< HEAD message = f\"Welcome, {name}! You are {age} years old. Your zodiac sign is {zodiac}. There are {days_to_bday} days until your next birthday!\" ======= message = f\"Hello, {name}! Your age is {age} and your zodiac sign is {zodiac}.\" >>>>>>> main Resolve the conflict by combining both changes: message = f\"Hello, {name}! Your age is {age} and your zodiac sign is {zodiac}. There are {days_to_bday} days until your next birthday!\" Stage the resolved file, commit the merge, and push: git add app.py git commit -m \"Merge main into feature/birthday-countdown and resolve conflicts\" git push origin feature/birthday-countdown Before moving to the next part, you can merge the feature branch into the main branch, either using a merge request or if you have the right to do it directly: git checkout main git merge feature/birthday-countdown Part 2: Rebasing with Conflicts Now, let's practice rebasing with a similar scenario. For Developer A: Create a new feature branch from main: git checkout main git pull origin main git checkout -b feature/lucky-number Add a lucky number feature to app.py : import random def get_lucky_number(): return random.randint(1, 100) @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] age = calculate_age(dob) zodiac = get_zodiac_sign(dob) lucky_number = get_lucky_number() message = f\"Hello, {name}! Your age is {age}, your zodiac sign is {zodiac}, and there are {days_to_bday} days until your next birthday. Your lucky number is {lucky_number}!\" return render_template('result.html', message=message) return render_template('index.html') Commit your changes: git add app.py git commit -m \"Add lucky number feature\" For Developer B: Make another change to the main branch: git checkout main git pull origin main Update the index function in app.py : @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] age = calculate_age(dob) zodiac = get_zodiac_sign(dob) days_to_bday = days_to_birthday(dob) message = f\"Greetings, {name}! You're {age} years old with the zodiac sign {zodiac}. Your next birthday is in {days_to_bday} days.\" return render_template('result.html', message=message) return render_template('index.html') Commit and push this change: git add app.py git commit -m \"Refine welcome message\" git push origin main Back to Developer A: Try to rebase your feature branch onto the updated main: git checkout feature/lucky-number git rebase main You'll encounter a rebase conflict. Open app.py and resolve the conflict: @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] age = calculate_age(dob) zodiac = get_zodiac_sign(dob) days_to_bday = days_to_birthday(dob) lucky_number = get_lucky_number() message = f\"Greetings, {name}! You're {age} years old with the zodiac sign {zodiac}. Your next birthday is in {days_to_bday} days. Your lucky number is {lucky_number}!\" return render_template('result.html', message=message) return render_template('index.html') After resolving the conflict: git add app.py git rebase --continue Force push your rebased branch: git push origin feature/lucky-number --force Make a merge request to merge the feature branch into the main branch. Stage 6: Implementing Tests for the Flask Application In this stage, we'll add tests to our Flask application to ensure its functionality and to practice test-driven development (TDD). We'll write both unit tests for individual functions and integration tests for the application routes. 1. Set Up Testing Environment First, we need to set up our testing environment: Install pytest, a popular testing framework for Python: pip install pytest Create a new file called test_app.py in your project root directory. 2. Writing Unit Tests Let's start by writing unit tests for our existing functions: Open test_app.py and add the following code: from app import calculate_age, get_zodiac_sign, days_to_birthday from datetime import date def test_calculate_age(): assert calculate_age(\"1990-01-01\") == date.today().year - 1990 def test_get_zodiac_sign(): assert get_zodiac_sign(\"1990-01-01\") == \"Capricorn\" assert get_zodiac_sign(\"1990-07-01\") == \"Cancer\" def test_days_to_birthday(): today = date.today() next_birthday = date(today.year, 12, 31) if next_birthday < today: next_birthday = date(today.year + 1, 12, 31) expected_days = (next_birthday - today).days assert days_to_birthday(\"2000-12-31\") == expected_days These tests check the core functionality of our utility functions. 3. Writing Integration Tests Now, let's add integration tests for our Flask routes: Add the following code to test_app.py : import pytest from app import app @pytest.fixture def client(): app.config['TESTING'] = True with app.test_client() as client: yield client def test_home_page(client): response = client.get('/') assert response.status_code == 200 assert b\"Welcome to the Birthday App\" in response.data def test_form_submission(client): response = client.post('/', data={ 'name': 'John Doe', 'dob': '1990-01-01' }, follow_redirects=True) assert response.status_code == 200 assert b\"John Doe\" in response.data assert b\"Your age is\" in response.data assert b\"Your zodiac sign is\" in response.data These tests check that our application's routes are working correctly. 4. Running the Tests To run the tests: In your terminal, navigate to your project directory. Run the following command: pytest You should see output indicating which tests passed or failed. In our case you should see that test_form_submission failed can you see why, and how to fix it? 5. Test-Driven Development: Adding a New Feature Test-Driven Development (TDD) is a software development approach where tests are written before the actual code. The TDD cycle, often referred to as Red-Green-Refactor, consists of three steps: Red: Write a test that fails. This test describes a desired functionality that doesn't exist yet. Green: Write the minimal amount of code necessary to make the test pass. The focus here is on making the test pass, not on writing perfect code. Refactor: Improve the code without changing its functionality. This step is about cleaning up the code, removing duplication, and ensuring it follows good design principles. The benefits of TDD include: Improved code quality: By thinking about how to test the code before writing it, developers often create more modular, flexible, and easier-to-maintain code. Better understanding of requirements: Writing tests first forces developers to clearly understand what the code should do before implementing it. Built-in regression testing: As features are added, the growing suite of tests helps ensure that new changes don't break existing functionality. Documentation: Tests serve as a form of documentation, showing how the code is expected to behave in various scenarios. Confidence in refactoring: With a comprehensive test suite, developers can refactor code with confidence, knowing that if they break something, a test will fail. Let's practice TDD by adding a new feature to determine if it's the user's birthday today. First, write a test for the new function in test_app.py : from app import is_birthday_today def test_is_birthday_today(): today = date.today() assert is_birthday_today(f\"{today.year}-{today.month:02d}-{today.day:02d}\") == True assert is_birthday_today(\"1990-01-01\") == (date.today().month == 1 and date.today().day == 1) Run the tests. The new test should fail because we haven't implemented the function yet. Now, implement the function in app.py : def is_birthday_today(dob): today = date.today() birth_date = datetime.strptime(dob, \"%Y-%m-%d\").date() return (today.month, today.day) == (birth_date.month, birth_date.day) Run the tests again. They should all pass now. Finally, update your index route to use this new function: @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] age = calculate_age(dob) zodiac = get_zodiac_sign(dob) days_to_bday = days_to_birthday(dob) is_birthday = is_birthday_today(dob) lucky_number = get_lucky_number() message = f\"Greetings, {name}! You're {age} years old with the zodiac sign {zodiac}. Your next birthday is in {days_to_bday} days. Your lucky number is {lucky_number}!\" if is_birthday: message += \"Happy Birthday!\" else: message += f\"There are {days_to_bday} days until your next birthday.\" return render_template('result.html', message=message) return render_template('index.html') Add a test for this new route behavior in test_app.py : def test_birthday_today(client): today = date.today() response = client.post('/', data={ 'name': 'John Doe', 'dob': f\"{today.year}-{today.month:02d}-{today.day:02d}\" }, follow_redirects=True) assert b\"Happy Birthday!\" in response.data Run the tests one final time to ensure everything is working. Stage 7: Introduction to CI/CD Continuous Integration (CI) and Continuous Deployment (CD) are practices in software development that aim to improve the process of building, testing, and releasing software. Continuous Integration (CI) Continuous Integration is the practice of frequently merging code changes into a shared repository. Each integration is verified by automated builds and tests. The main goals of CI are: Detect and address integration issues early Improve software quality Reduce the time to validate and release new updates With CI, developers integrate their work frequently, usually daily, leading to multiple integrations per day. Each integration triggers automated builds and tests to detect issues quickly. Continuous Deployment (CD) Continuous Deployment takes CI one step further. In CD, every change that passes the automated tests is automatically deployed to production. The main benefits of CD are: Faster release cycles Reduced manual processes and human error More frequent user feedback Improved developer productivity CD can also refer to Continuous Delivery, where changes are automatically deployed to a staging environment but require manual approval for production deployment. Why CI/CD is Useful Faster Bug Detection and Resolution : Issues are caught earlier in the development process, making them easier and less expensive to fix. Improved Collaboration : Frequent integration encourages communication between team members and keeps everyone up to date with changes. Higher Quality Software : Automated testing ensures that tests are run consistently and frequently, catching bugs that might be missed in manual testing. Faster Time to Market : Automating the build, test, and deployment processes reduces the time between writing code and using it in production. Reduced Risk : Smaller, more frequent updates are less risky and easier to roll back if issues occur. Increased Confidence : With a robust CI/CD pipeline, teams can be more confident in the stability and quality of their code. In the following section, we'll implement a basic CI/CD pipeline using GitLab Actions, experiencing firsthand how these practices can improve our development workflow. Implementing CI/CD with GitLab In this final part, we'll set up a Continuous Integration/Continuous Deployment (CI/CD) pipeline using GitLab Actions. We'll deliberately introduce a failing test, observe it fail both locally and in the CI pipeline, and then fix it. 1. Setting Up GitLab CI/CD In your local repository, create a new file named .gitlab-ci.yml in the root directory: touch .gitlab-ci.yml Create a new file .GitLab/workflows/python-app.yml with the following content: image: python:3.8 stages: - test before_script: - python -m pip install --upgrade pip - pip install flask pytest test: stage: test script: - pytest only: - main - merge_requests This GitLab CI/CD configuration does the following: Uses a Python 3.8 Docker image for the CI environment Defines a single stage called \"test\" Installs the necessary dependencies (Flask and pytest) Runs the pytest command to execute the tests Triggers the pipeline on pushes to the main branch and for merge requests Commit and push this new file: git add .gitlab-ci.yml git commit -m \"Add GitLab CI/CD configuration\" git push origin main 2. Introducing a Failing Test Let's modify our calculate_age function to introduce a bug, and update its test to catch this bug. In app.py , change the calculate_age function: def calculate_age(dob): today = date.today() birth_date = datetime.strptime(dob, \"%Y-%m-%d\").date() age = today.year - birth_date.year # Introduce a bug: forget to check if birthday has occurred this year return age # This might be off by one year In test_app.py , update the test_calculate_age function: def test_calculate_age(): today = date.today() assert calculate_age(f\"{today.year-30}-{today.month:02d}-{today.day:02d}\") == 30 assert calculate_age(f\"{today.year-30}-{today.month:02d}-{today.day+1:02d}\") == 29 # This will fail 3. Running Tests Locally Run the tests locally to see the failure: pytest You should see that the second assertion in test_calculate_age fails. 4. Pushing to GitLab and Observing CI Failure Commit and push these changes: git add app.py test_app.py git commit -m \"Update calculate_age function and its test\" git push origin main Go to your GitLab repository, click on the \"Build/Pipelines\" tab, and you should see the pipeline running. It will fail due to the failing test. Because of that failure, the code won't be deployed to the production environment. You can think of the pipeline as a way to ensure that the code is working as expected before it is deployed to the production environment. 5. Fixing the Bug Now, let's fix the bug in the calculate_age function: In app.py , correct the calculate_age function: def calculate_age(dob): today = date.today() birth_date = datetime.strptime(dob, \"%Y-%m-%d\").date() age = today.year - birth_date.year # Check if birthday has occurred this year if today < date(today.year, birth_date.month, birth_date.day): age -= 1 return age Commit and push the fix: git add app.py git commit -m \"Fix calculate_age function\" git push origin main Go back to the GitLab tab and watch the new workflow run. It should pass all tests now. By following these steps, you've implemented a basic CI/CD pipeline using GitLab. This pipeline will automatically run your tests whenever you push changes to the repository, helping you catch issues early and ensure the quality of your code.","title":"Introduction to Git and GitLab"},{"location":"Introduction_git/#introduction-to-git-gitlab-and-cicd","text":"","title":"Introduction to Git, GitLab and CI/CD"},{"location":"Introduction_git/#introduction","text":"This practical session is designed for small groups of 2-3 people to work through together. It is very important that every member of the group runs the different commands in this practical session all shared with the same repository (we will see later what this means). During this project, you will learn if not already, how to use Git and GitLab to manage your code and to collaborate with your team. You will also learn how to use GitLab Actions to deploy your code and to run tests. This practical session is not a full Git and GitLab course, but rather a practical introduction to these tools providing you with the basic knowledge to be able to use them during this project. If you want to learn more about Git and GitLab, you can refer to the official documentation .","title":"Introduction:"},{"location":"Introduction_git/#understanding-version-control","text":"Version control is a system that helps track and manage changes to files over time. It's an essential tool for software development, enabling developers to collaborate effectively, maintain a history of changes, and manage different versions of their code. With version control, you can revert files to a previous state, compare changes over time, see who last modified something that might be causing issues, and more. It acts as a safety net, allowing developers to experiment with new ideas without fear of losing their original work.","title":"Understanding Version Control"},{"location":"Introduction_git/#example","text":"Imagine you're working on a Python application for a bookstore. Over time, you add several features, but one of them turns out to be problematic. With version control, you can easily remove just the unwanted feature while keeping the other improvements. Let's see how this might look: Day 1: You start with a basic Book class. class Book: def __init__(self, title, author, price): self.title = title self.author = author self.price = price def display_info(self): return f\"{self.title} by {self.author}: ${self.price}\" Day 3: You add a discount feature. class Book: def __init__(self, title, author, price): self.title = title self.author = author self.price = price def display_info(self): return f\"{self.title} by {self.author}: ${self.price}\" def apply_discount(self, discount): self.price = self.price * (1 - discount) Day 5: You add a feature to track stock, but it has a bug. class Book: def __init__(self, title, author, price, stock): self.title = title self.author = author self.price = price self.stock = stock def display_info(self): return f\"{self.title} by {self.author}: ${self.price} (In stock: {self.stock})\" def apply_discount(self, discount): self.price = self.price * (1 - discount) def update_stock(self, quantity): self.stock += quantity # Bug: This allows negative stock! Day 7: You add a method to calculate total value. class Book: def __init__(self, title, author, price, stock): self.title = title self.author = author self.price = price self.stock = stock def display_info(self): return f\"{self.title} by {self.author}: ${self.price} (In stock: {self.stock})\" def apply_discount(self, discount): self.price = self.price * (1 - discount) def update_stock(self, quantity): self.stock += quantity # Bug: This allows negative stock! def total_value(self): return self.price * self.stock Day 10: You realize the stock tracking feature has a bug allowing negative stock. With version control, you can: 1. Review the history of changes to identify when the bug was introduced. 2. Revert just the problematic update_stock method while keeping the other beneficial changes. 3. Fix the bug and commit the corrected version. The corrected version might look like this: class Book: def __init__(self, title, author, price, stock): self.title = title self.author = author self.price = price self.stock = stock def display_info(self): return f\"{self.title} by {self.author}: ${self.price} (In stock: {self.stock})\" def apply_discount(self, discount): self.price = self.price * (1 - discount) def update_stock(self, quantity): if self.stock + quantity >= 0: self.stock += quantity else: raise ValueError(\"Stock cannot be negative\") def total_value(self): return self.price * self.stock This example demonstrates how version control allows you to: - Track the evolution of your code over time - Identify when and where issues were introduced - Selectively keep or discard changes - Maintain a history of your development process Modern development teams use version control systems to manage their code, track changes, and collaborate effectively. Git is one of the most popular version control systems, providing a robust set of features for managing codebases of all sizes.","title":"Example:"},{"location":"Introduction_git/#git","text":"Git is a distributed version control system that has revolutionized how developers manage and track changes in their code. Created by Linus Torvalds in 2005, Git was born out of the need for a fast, efficient, and reliable system to manage the development of the Linux kernel. Unlike centralized version control systems that preceded it, Git allows developers to have a complete copy of the project history on their local machines, enabling offline work and providing a safeguard against data loss. Git's distributed nature facilitates collaboration among developers, allowing them to work on different features simultaneously and merge their changes seamlessly. Its branching and merging capabilities make it easy to experiment with new ideas without affecting the main codebase. Since its inception, Git has become the de facto standard for version control in software development, used by millions of developers and organizations worldwide.","title":"Git"},{"location":"Introduction_git/#gits-basic-paradigms","text":"Snapshots, Not Differences : Unlike other version control systems that store data as changes to a base version of each file, Git thinks of its data more like a series of snapshots of a miniature filesystem. Every time you commit, or save the state of your project in Git, it basically takes a picture of what all your files look like at that moment and stores a reference to that snapshot. Local Operations : Most operations in Git need only local files and resources to operate. This means you can work on your project even when you're offline or not on a VPN, unlike centralized systems that need to communicate with a server for almost every operation. Integrity : Everything in Git is check-summed before it is stored and is then referred to by that checksum. This means it's impossible to change the contents of any file or directory without Git knowing about it. This functionality is built into Git at the lowest levels and is integral to its philosophy. Branching Model : Git's branching model is its \"killer feature.\" Unlike many other VCSs, Git encourages workflows that branch and merge often. This allows for feature branches, experimentation, and parallel development streams that can be easily merged when ready. Distributed Development : In Git, every developer's working copy of the code is also a repository that can contain the full history of all changes. This allows for multiple backup copies and various collaborative development models. Fast and Lightweight : Git is designed to be fast and efficient with large projects. Most operations are local, reducing the overhead of communicating with a centralized server.","title":"Git's Basic Paradigms"},{"location":"Introduction_git/#the-three-states-in-git","text":"In Git, files can exist in three states: Modified : You have changed the file but have not committed it to your database yet. Staged : You have marked a modified file in its current version to go into your next commit snapshot. Committed : The data is safely stored in your local database. These three states correspond to the three main sections of a Git project. When not tracked by Git, a file is in the Untracked state.","title":"The Three States in Git"},{"location":"Introduction_git/#git-areas-and-workflow","text":"Understanding the different areas in Git is crucial for mastering its workflow. Git manages your project's files through four main areas: Working Directory (Working Tree) : This is where you actually work on your project files. It's a single checkout of one version of the project. These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify. Staging Area (Index) : This is a file, generally contained in your Git directory, that stores information about what will go into your next commit. It's sometimes referred to as the \"Index\". Think of it as a prep area for your next commit. Files are added to this area with the git add command. Local Repository : This is where Git stores the metadata and object database for your project. It's what's copied when you clone a repository from another computer. The local repository contains all of your committed changes. It's located in the .git directory of your project. Remote Repository : This is a version of your project that is hosted on the Internet or network somewhere (like GitHub, GitLab, or Bitbucket). You can have several of them, each of which generally is either read-only or read/write for you. Collaborating with others involves managing your remote repositories and pushing and pulling data to and from them when you need to share work.","title":"Git Areas and Workflow"},{"location":"Introduction_git/#basic-git-workflow","text":"You modify files in your Working Directory. You stage the files, adding snapshots of them to your Staging Area. You do a commit, which takes the files as they are in the Staging Area and stores that snapshot permanently to your Local Repository. You push your changes to a Remote Repository to share with others or as a backup. Understanding these areas and how they interact is key to understanding Git's workflow and effectively managing your projects with version control.","title":"Basic Git Workflow:"},{"location":"Introduction_git/#gitlab","text":"GitLab is a web-based hosting service for Git repositories. Launched in 2008, it has become the world's largest host of source code and a central hub for collaboration among developers. While Git is a command-line tool, GitLab provides a web-based graphical interface. It also offers access control and several collaboration features, such as bug tracking, feature requests, task management, and wikis for every project. Key features of GitLab include: Repository Hosting : GitLab can host your Git repositories in the cloud, making it easy to share and collaborate on code. Fork and Pull Request : Users can \"fork\" an existing repository (creating their own copy), make changes, and then submit a \"pull request\" to propose those changes back to the original project. Issue Tracking : GitLab provides a system for reporting and managing bugs, feature requests, and other tasks related to a project. Project Management Tools : Including project boards, milestones, and other tools to help manage and organize work on repositories. Social Coding : Users can follow repositories and other users, star repositories they like, and see a feed of activity from repositories and users they're interested in. GitLab Pages : A feature that allows hosting of static websites directly from a GitLab repository. Integrations : GitLab can integrate with many third-party services, enhancing its capabilities for things like continuous integration and deployment. GitLab has played a significant role in the growth of open-source software, providing a platform where developers from around the world can collaborate on projects. It's used not only by individual developers and open-source projects but also by large companies to host and manage their code.","title":"GitLab"},{"location":"Introduction_git/#setting-up-your-environment","text":"","title":"Setting up your environment"},{"location":"Introduction_git/#anaconda-and-python","text":"Download and install Anaconda from the official website: https://www.anaconda.com/products/distribution During installation, make sure to add Anaconda to your PATH environment variable when prompted. Open an Anaconda Prompt (on Windows) or a terminal (on macOS/Linux). Create a new environment for this project: conda create --name gitproject python=3.8 Activate the environment: conda activate gitproject Install Flask (we'll use it for examples during the session): pip install flask","title":"Anaconda and Python:"},{"location":"Introduction_git/#git_1","text":"1. Download Git from the official website: https://git-scm.com/downloads 2. Follow the installation instructions for your operating system. 3. After installation, open a new terminal or command prompt and verify the installation: git --version Configure your Git username and email: git config --global user.name \"Your Name\" git config --global user.email \"your.email@example.com\"","title":"Git"},{"location":"Introduction_git/#gitlab_1","text":"We will use GitLab as our remote repository for this project. A GitLab server is already hosted at INSA, you can access it at https://gitlab-ens.insa-toulouse.fr/ (you need to be connected to the INSA VPN to access it). Verify that you do have a GitLab account.","title":"GitLab"},{"location":"Introduction_git/#remote-repository","text":"(Just one person in the group should do this and invite others to collaborate) Log in to GitLab. Click the create a project button. Name your repository (e.g., \"flask-git-demo\"). Choose to make it public. Initialize the repository with a README file. Click \"Create project\". To invite collaborators: Go to your repository's page. On the left menu, click on \"Members\" and invite the other members of the group. Give them the \"Developer\" role.","title":"Remote repository"},{"location":"Introduction_git/#local-repository","text":"Open a terminal or command prompt. Navigate to the directory where you want to create your project: cd path/to/your/project/directory Clone the remote repository: git clone https://GitLab.com/your-username/flask-git-demo.git (Replace 'your-username' with the GitLab username of the person who created the repository) 4. Navigate into the cloned repository: cd flask-git-demo Now your environment is set up and ready for the Git and GitLab practical session. Each member of the group should have Python, Flask, and Git installed, a GitLab account, and a local copy of the repository. The repository owner has set up the remote repository and invited other group members as collaborators.","title":"Local repository"},{"location":"Introduction_git/#practical-session-a-flask-web-app-development-with-git-and-gitlab","text":"We'll build a Flask web app that collects a user's name and date of birth, then displays various information based on this input. We'll develop this app in stages, using Git and GitLab to manage our development process.","title":"Practical session: A Flask Web App Development with Git and GitLab"},{"location":"Introduction_git/#stage-1-basic-setup-and-first-commit-explained-guide","text":"In this stage, we'll set up a basic Flask app within our existing Git repository. To avoid conflicts, only one person (the team lead) should perform the initial setup and push the changes. Other team members will then pull these changes.","title":"Stage 1: Basic Setup and First Commit - Explained Guide"},{"location":"Introduction_git/#for-the-team-lead","text":"","title":"For the Team Lead:"},{"location":"Introduction_git/#1-navigate-to-the-project-directory","text":"First, we need to ensure we're in the correct directory for our project. cd path/to/flask-git-demo This command changes the current directory to your project folder.","title":"1. Navigate to the Project Directory"},{"location":"Introduction_git/#2-create-the-flask-app","text":"Now, we'll create the basic structure for our Flask application. Create a new file called app.py : touch app.py # touch is a command that creates an empty file # on windows just create it manually This command creates an empty file named app.py . Open app.py in your preferred text editor and add the following code: from flask import Flask, render_template, request from datetime import datetime app = Flask(__name__) @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] welcome_message = f\"Welcome, {name}! Your date of birth is {dob}.\" return render_template('result.html', message=welcome_message) return render_template('index.html') if __name__ == '__main__': app.run(debug=True) This code sets up a basic Flask app with a route that handles both GET and POST requests. Create a new directory for our HTML templates: mkdir templates # mkdir is a command that creates a new directory # on windows just create it manually This command creates a new directory named \"templates\", where Flask will look for our HTML files. Create two HTML files in the templates directory: For index.html : touch templates/index.html # on windows just create it manually Then add the HTML content for the form in your text editor. <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Birthday App</title> <link rel=\"stylesheet\" href=\"{{ url_for('static', filename='style.css') }}\"> </head> <body> <h1>Welcome to the Birthday App</h1> <form method=\"POST\"> <label for=\"name\">Name:</label> <input type=\"text\" id=\"name\" name=\"name\" required> <label for=\"dob\">Date of Birth:</label> <input type=\"date\" id=\"dob\" name=\"dob\" required> <input type=\"submit\" value=\"Submit\"> </form> </body> </html> For result.html : touch templates/result.html # on windows just create it manually Then add the HTML content for the result page in your text editor. <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Birthday App Result</title> <link rel=\"stylesheet\" href=\"{{ url_for('static', filename='style.css') }}\"> </head> <body> <h1>Your Birthday Information</h1> <p>{{ message }}</p> <a href=\"{{ url_for('index') }}\">Go back</a> </body> </html>","title":"2. Create the Flask App"},{"location":"Introduction_git/#3-update-gitignore","text":"To keep our repository clean, we'll update the .gitignore file to exclude unnecessary files. echo \"venv/\" >> .gitignore echo \"__pycache__/\" >> .gitignore echo \"*.pyc\" >> .gitignore These commands append new lines to the .gitignore file, telling Git to ignore the virtual environment directory, Python cache files, and compiled Python files. By adding these files to the .gitignore file, we ensure that they are not tracked by Git, meaning they won't be committed to the repository.","title":"3. Update .gitignore"},{"location":"Introduction_git/#4-git-operations","text":"Now we'll use Git to track our new files and push them to the remote repository. Check the status of your repository: git status This command shows you which files have been changed or are untracked. Add the new files to the staging area: git add . This stages all new and modified files, preparing them for commit. Check the status again to verify that the files have been staged: git status Commit the changes: git commit -m \"Add basic Flask app structure\" This creates a new commit with the staged changes and adds a descriptive message. Check the status again to verify that the commit has been created: git status Push the changes to the remote repository: git push origin main This uploads your local commits to the remote repository on GitLab. Check the status again to verify that the commit has been pushed: git status","title":"4. Git Operations"},{"location":"Introduction_git/#5-testing-the-app","text":"Before notifying your team, make sure the app works as expected: python app.py This command runs your Flask application. Open a web browser and go to http://127.0.0.1:5000/ to verify the app is functioning correctly.","title":"5. Testing the App"},{"location":"Introduction_git/#6-notify-team-members","text":"Once you've successfully pushed the changes and tested the app, notify your team members that the initial setup is complete and they can proceed with their steps.","title":"6. Notify Team Members"},{"location":"Introduction_git/#for-other-team-members","text":"After the team lead has completed the setup and pushed the changes, follow these steps: Pull the latest changes from the remote repository: git pull origin main This command fetches the latest changes from the remote repository and merges them into your local branch. Test the app to ensure it's working on your local machine: python app.py This runs the Flask application. Check http://127.0.0.1:5000/ in your browser to verify it's working correctly.","title":"For Other Team Members:"},{"location":"Introduction_git/#collaboration-notes","text":"Always pull the latest changes before starting work each day: git pull origin main This ensures you're working with the most up-to-date version of the project. If you encounter any issues or merge conflicts, communicate with your team to resolve them. Remember to commit your changes frequently with meaningful commit messages as you start working on new features in the upcoming stages. In the next stages, we'll add more features to this app and explore more Git and GitLab concepts as a team.","title":"Collaboration Notes"},{"location":"Introduction_git/#stage-2-implementing-age-calculation-direct-implementation","text":"In this stage, we'll add a feature to calculate the user's age based on their date of birth. We'll implement this directly on the main branch to practice basic Git workflows.","title":"Stage 2: Implementing Age Calculation - Direct Implementation"},{"location":"Introduction_git/#for-the-student-lead-of-stage-2","text":"","title":"For the Student Lead of Stage 2:"},{"location":"Introduction_git/#1-prepare-your-local-repository","text":"Ensure your local repository is up-to-date: git pull origin main This fetches and merges the latest changes from the main branch.","title":"1. Prepare Your Local Repository"},{"location":"Introduction_git/#2-implement-age-calculation","text":"Open app.py and add a new function to calculate age: from datetime import datetime def calculate_age(dob): today = datetime.today() birth_date = datetime.strptime(dob, \"%Y-%m-%d\") age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day)) return age Modify the index function to use this new calculation: @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] age = calculate_age(dob) welcome_message = f\"Welcome, {name}! You are {age} years old.\" return render_template('result.html', message=welcome_message) return render_template('index.html')","title":"2. Implement Age Calculation"},{"location":"Introduction_git/#3-test-your-changes","text":"Run the Flask application to test your changes: python app.py Verify that the age calculation works correctly by submitting the form and checking the result.","title":"3. Test Your Changes"},{"location":"Introduction_git/#4-commit-your-changes","text":"After confirming that everything works: git add app.py git commit -m \"Add age calculation feature\" This stages and commits your changes to your local main branch.","title":"4. Commit Your Changes"},{"location":"Introduction_git/#5-push-your-changes","text":"Push your commits to the remote repository: git push origin main This updates the main branch on GitLab with your new changes.","title":"5. Push Your Changes"},{"location":"Introduction_git/#6-notify-team-members_1","text":"Let your team know that you've pushed new changes to the main branch.","title":"6. Notify Team Members"},{"location":"Introduction_git/#for-other-team-members_1","text":"After the student lead has pushed the changes: Pull the latest changes from the remote repository: git pull origin main This updates your local main branch with the new changes. Test the updated application to ensure everything works correctly: python app.py If you encounter any issues, communicate with the team to resolve them.","title":"For Other Team Members:"},{"location":"Introduction_git/#stage-3-adding-zodiac-sign-feature-branching-and-pull-requests","text":"Now that we've implemented a feature directly on the main branch, let's discuss the concept of branching and why it's useful: Branching in Git allows developers to diverge from the main line of development and work independently on features or experiments without affecting the main codebase. This has several advantages: Isolation : You can work on different features or experiments without interfering with the main codebase or other developers' work. Easier collaboration : Multiple developers can work on different features simultaneously without conflicts. Code review : Branches facilitate code reviews through pull requests before merging changes into the main codebase. Experimentation : You can try out ideas without the risk of breaking the main codebase. In this stage, we'll add a feature to determine the user's zodiac sign based on their date of birth. We'll use Git branching and create a pull request to implement this feature, demonstrating a more advanced Git workflow.","title":"Stage 3: Adding Zodiac Sign Feature - Branching and Pull Requests"},{"location":"Introduction_git/#for-the-student-lead-of-stage-3","text":"","title":"For the Student Lead of Stage 3:"},{"location":"Introduction_git/#1-ensure-your-repository-is-up-to-date","text":"First, make sure you're on the main branch and it's up-to-date: git checkout main git pull origin main","title":"1. Ensure Your Repository is Up-to-Date"},{"location":"Introduction_git/#2-create-a-new-branch","text":"Create and switch to a new branch for the zodiac sign feature: git checkout -b feature/zodiac-sign","title":"2. Create a New Branch"},{"location":"Introduction_git/#3-implement-the-zodiac-sign-feature","text":"In app.py , add a new function to determine the zodiac sign: def get_zodiac_sign(dob): month, day = map(int, dob.split('-')[1:]) zodiac_signs = [ (1, 20, \"Capricorn\"), (2, 19, \"Aquarius\"), (3, 20, \"Pisces\"), (4, 20, \"Aries\"), (5, 21, \"Taurus\"), (6, 21, \"Gemini\"), (7, 22, \"Cancer\"), (8, 23, \"Leo\"), (9, 23, \"Virgo\"), (10, 23, \"Libra\"), (11, 22, \"Scorpio\"), (12, 22, \"Sagittarius\"), (12, 31, \"Capricorn\") ] for m, d, sign in zodiac_signs: if (month, day) <= (m, d): return sign Modify the index function to include the zodiac sign: @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] age = calculate_age(dob) zodiac = get_zodiac_sign(dob) message = f\"Welcome, {name}! You are {age} years old. Your zodiac sign is {zodiac}.\" return render_template('result.html', message=message) return render_template('index.html')","title":"3. Implement the Zodiac Sign Feature"},{"location":"Introduction_git/#4-test-your-changes","text":"Run the Flask application and test the new feature: python app.py","title":"4. Test Your Changes"},{"location":"Introduction_git/#5-commit-your-changes","text":"After ensuring everything works: git add app.py git commit -m \"Add zodiac sign feature\"","title":"5. Commit Your Changes"},{"location":"Introduction_git/#6-push-your-branch-to-gitlab","text":"Push your feature branch to the remote repository: git push -u origin feature/zodiac-sign","title":"6. Push Your Branch to GitLab"},{"location":"Introduction_git/#7-create-a-pull-request","text":"Go to your repository on GitLab. You should see a prompt to create a merge request for your recently pushed branch. Click on it. Fill in the details of your merge request, describing the new zodiac sign feature. Assign team members to review your merge request.","title":"7. Create a Pull Request"},{"location":"Introduction_git/#for-other-team-members-reviewers","text":"","title":"For Other Team Members (Reviewers):"},{"location":"Introduction_git/#reviewing-the-pull-request","text":"Go to the repository on GitLab and navigate to the \"Merge requests\" tab on the left menu. Click on the merge request for the zodiac sign feature. Review the changes: Check the code for correctness and style. Consider how this feature integrates with the existing codebase. To test the changes locally: git fetch origin # to update the local repository with the latest changes from the remote repository git checkout feature/zodiac-sign # to switch to the feature branch python app.py # to test the changes locally Leave comments or request changes if necessary. If everything looks good, approve the pull request.","title":"Reviewing the Pull Request"},{"location":"Introduction_git/#after-the-pull-request-is-merged","text":"Once the pull request is approved and merged: Switch back to the main branch: git checkout main Pull the latest changes: git pull origin main Test the updated application to ensure everything works correctly. In the next stage, we'll continue to build on our app and explore more advanced Git and GitLab features, such as handling merge conflicts.","title":"After the Pull Request is Merged"},{"location":"Introduction_git/#stage-4-enhancing-the-ui-git-stash-and-gitlab-issues","text":"In this stage, we'll improve the user interface of our Flask application by adding some basic CSS. We'll also learn about Git stash for managing temporary changes and use GitLab Issues for task tracking.","title":"Stage 4: Enhancing the UI - Git Stash and GitLab Issues"},{"location":"Introduction_git/#for-the-project-manager-can-be-any-team-member","text":"","title":"For the Project Manager (can be any team member):"},{"location":"Introduction_git/#1-create-gitlab-issues","text":"Go to your GitLab repository and navigate to the \"Issues\" tab. Create a new issue titled \"Enhance UI with CSS\". In the description, outline the following tasks: Add a CSS file for styling Style the form on the index page Improve the layout of the result page Add labels like \"enhancement\" and \"ui\". Assign the issue to a team member.","title":"1. Create GitLab Issues"},{"location":"Introduction_git/#for-the-assigned-team-member","text":"","title":"For the Assigned Team Member:"},{"location":"Introduction_git/#1-set-up-your-work-environment","text":"Ensure your local repository is up-to-date: git checkout main git pull origin main","title":"1. Set Up Your Work Environment"},{"location":"Introduction_git/#2-create-a-new-branch_1","text":"Create a branch for the UI enhancements: git checkout -b feature/ui-enhancement","title":"2. Create a New Branch"},{"location":"Introduction_git/#3-add-css-file","text":"Create a new directory named static in your project root: mkdir static Create a new CSS file: touch static/style.css Add some basic CSS to style.css : body { font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; background-color: #f4f4f4; } h1 { color: #333; } form { background-color: #fff; padding: 20px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.1); } input[type=\"text\"], input[type=\"date\"] { width: 100%; padding: 8px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 4px; } input[type=\"submit\"] { background-color: #333; color: #fff; border: none; padding: 10px 20px; cursor: pointer; border-radius: 4px; } input[type=\"submit\"]:hover { background-color: #555; }","title":"3. Add CSS File"},{"location":"Introduction_git/#4-test-your-changes_1","text":"Run the Flask application and verify the UI improvements: python app.py","title":"4. Test Your Changes"},{"location":"Introduction_git/#5-demonstrate-git-stash","text":"Let's say you notice a small bug in the age calculation while working on the UI. Here's how to use Git stash: Make a small change in app.py to fix the bug. Instead of committing this change, use Git stash: git stash save \"Fix age calculation bug\" Your working directory is now clean and back to the state of the last commit. To apply the stashed changes later: git stash pop","title":"5. Demonstrate Git Stash"},{"location":"Introduction_git/#6-commit-ui-changes","text":"Now, commit your UI enhancements: git add static/style.css templates/index.html templates/result.html git commit -m \"Enhance UI with CSS styling\"","title":"6. Commit UI Changes"},{"location":"Introduction_git/#7-push-and-create-pull-request","text":"Push your branch and create a merge request: git push -u origin feature/ui-enhancement Create a pull request on GitLab, referencing the issue number in the description (e.g., \"Closes #1\").","title":"7. Push and Create Pull Request"},{"location":"Introduction_git/#for-reviewers","text":"Review the pull request, checking both the code and the visual changes. Test the changes locally if necessary. Provide feedback or approve the changes.","title":"For Reviewers:"},{"location":"Introduction_git/#after-merging","text":"Close the GitLab issue once the pull request is merged. All team members should pull the latest changes: git checkout main git pull origin main Discuss as a team: 1. How did using GitLab Issues help in organizing the task? 2. What was your experience with Git stash? How might it be useful in other scenarios? 3. How has the workflow evolved from the earlier stages of the project? In the next stage, we'll implement a more complex feature and explore handling merge conflicts.","title":"After Merging:"},{"location":"Introduction_git/#stage-5-merging-and-rebasing-with-conflicts","text":"Git offers two primary ways to integrate changes from one branch into another: merging and rebasing.","title":"Stage 5: Merging and Rebasing with Conflicts"},{"location":"Introduction_git/#merge","text":"Merging creates a new commit that combines the tips of two branches. This method preserves the entire history of both branches, providing a non-destructive operation that maintains a clear record of when branches diverged and were integrated. The resulting history shows the parallel development that occurred, with a visible branching structure. Merging is particularly safe for shared branches as it doesn't rewrite history. However, in projects with frequent merges, this can lead to a more complex history that may be harder to follow.","title":"Merge"},{"location":"Introduction_git/#rebase","text":"Rebasing, on the other hand, moves the entire feature branch to begin on the tip of the main branch, effectively replaying your work on top of it. This results in a linear project history, as if the work was done sequentially rather than in parallel. Rebasing creates a cleaner, more streamlined history which can make it easier to track features. However, it achieves this by rewriting the project history, which can be problematic if the rebased branch has been shared with others. As such, rebasing requires more care when used on public or shared branches. The choice between merging and rebasing often depends on the specific needs of your project and team. Merging is generally preferred for preserving complete history and for work on public branches, while rebasing is often used to maintain a cleaner history, especially for local branches or before merging a feature branch into the main line of development. In this stage, we'll practice merging and rebasing, including handling conflicts. We'll do this by creating a new feature branch, making changes to the main branch, and then exploring both merge and rebase workflows.","title":"Rebase"},{"location":"Introduction_git/#part-1-merging-with-conflicts","text":"","title":"Part 1: Merging with Conflicts"},{"location":"Introduction_git/#for-developer-a","text":"Ensure your main branch is up-to-date: git checkout main git pull origin main Create a new branch for a feature: git checkout -b feature/birthday-countdown Implement the birthday countdown feature in app.py : from datetime import datetime, date def days_to_birthday(dob): today = date.today() dob = datetime.strptime(dob, \"%Y-%m-%d\").date() next_birthday = date(today.year, dob.month, dob.day) if next_birthday < today: next_birthday = date(today.year + 1, dob.month, dob.day) return (next_birthday - today).days @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] age = calculate_age(dob) zodiac = get_zodiac_sign(dob) days_to_bday = days_to_birthday(dob) message = f\"Welcome, {name}! You are {age} years old. Your zodiac sign is {zodiac}. There are {days_to_bday} days until your next birthday!\" return render_template('result.html', message=message) return render_template('index.html') Commit your changes: git add app.py git commit -m \"Add birthday countdown feature\"","title":"For Developer A:"},{"location":"Introduction_git/#for-developer-b","text":"Make sure you're on the main branch and it's up-to-date: git checkout main git pull origin main Make a change to the index function in app.py : @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] age = calculate_age(dob) zodiac = get_zodiac_sign(dob) message = f\"Hello, {name}! Your age is {age} and your zodiac sign is {zodiac}.\" return render_template('result.html', message=message) return render_template('index.html') Commit and push this change: git add app.py git commit -m \"Update welcome message format\" git push origin main","title":"For Developer B:"},{"location":"Introduction_git/#back-to-developer-a","text":"Try to merge the main branch into your feature branch: git checkout feature/birthday-countdown git merge main You'll encounter a merge conflict. Open app.py and you'll see something like: <<<<<<< HEAD message = f\"Welcome, {name}! You are {age} years old. Your zodiac sign is {zodiac}. There are {days_to_bday} days until your next birthday!\" ======= message = f\"Hello, {name}! Your age is {age} and your zodiac sign is {zodiac}.\" >>>>>>> main Resolve the conflict by combining both changes: message = f\"Hello, {name}! Your age is {age} and your zodiac sign is {zodiac}. There are {days_to_bday} days until your next birthday!\" Stage the resolved file, commit the merge, and push: git add app.py git commit -m \"Merge main into feature/birthday-countdown and resolve conflicts\" git push origin feature/birthday-countdown Before moving to the next part, you can merge the feature branch into the main branch, either using a merge request or if you have the right to do it directly: git checkout main git merge feature/birthday-countdown","title":"Back to Developer A:"},{"location":"Introduction_git/#part-2-rebasing-with-conflicts","text":"Now, let's practice rebasing with a similar scenario.","title":"Part 2: Rebasing with Conflicts"},{"location":"Introduction_git/#for-developer-a_1","text":"Create a new feature branch from main: git checkout main git pull origin main git checkout -b feature/lucky-number Add a lucky number feature to app.py : import random def get_lucky_number(): return random.randint(1, 100) @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] age = calculate_age(dob) zodiac = get_zodiac_sign(dob) lucky_number = get_lucky_number() message = f\"Hello, {name}! Your age is {age}, your zodiac sign is {zodiac}, and there are {days_to_bday} days until your next birthday. Your lucky number is {lucky_number}!\" return render_template('result.html', message=message) return render_template('index.html') Commit your changes: git add app.py git commit -m \"Add lucky number feature\"","title":"For Developer A:"},{"location":"Introduction_git/#for-developer-b_1","text":"Make another change to the main branch: git checkout main git pull origin main Update the index function in app.py : @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] age = calculate_age(dob) zodiac = get_zodiac_sign(dob) days_to_bday = days_to_birthday(dob) message = f\"Greetings, {name}! You're {age} years old with the zodiac sign {zodiac}. Your next birthday is in {days_to_bday} days.\" return render_template('result.html', message=message) return render_template('index.html') Commit and push this change: git add app.py git commit -m \"Refine welcome message\" git push origin main","title":"For Developer B:"},{"location":"Introduction_git/#back-to-developer-a_1","text":"Try to rebase your feature branch onto the updated main: git checkout feature/lucky-number git rebase main You'll encounter a rebase conflict. Open app.py and resolve the conflict: @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] age = calculate_age(dob) zodiac = get_zodiac_sign(dob) days_to_bday = days_to_birthday(dob) lucky_number = get_lucky_number() message = f\"Greetings, {name}! You're {age} years old with the zodiac sign {zodiac}. Your next birthday is in {days_to_bday} days. Your lucky number is {lucky_number}!\" return render_template('result.html', message=message) return render_template('index.html') After resolving the conflict: git add app.py git rebase --continue Force push your rebased branch: git push origin feature/lucky-number --force Make a merge request to merge the feature branch into the main branch.","title":"Back to Developer A:"},{"location":"Introduction_git/#stage-6-implementing-tests-for-the-flask-application","text":"In this stage, we'll add tests to our Flask application to ensure its functionality and to practice test-driven development (TDD). We'll write both unit tests for individual functions and integration tests for the application routes.","title":"Stage 6: Implementing Tests for the Flask Application"},{"location":"Introduction_git/#1-set-up-testing-environment","text":"First, we need to set up our testing environment: Install pytest, a popular testing framework for Python: pip install pytest Create a new file called test_app.py in your project root directory.","title":"1. Set Up Testing Environment"},{"location":"Introduction_git/#2-writing-unit-tests","text":"Let's start by writing unit tests for our existing functions: Open test_app.py and add the following code: from app import calculate_age, get_zodiac_sign, days_to_birthday from datetime import date def test_calculate_age(): assert calculate_age(\"1990-01-01\") == date.today().year - 1990 def test_get_zodiac_sign(): assert get_zodiac_sign(\"1990-01-01\") == \"Capricorn\" assert get_zodiac_sign(\"1990-07-01\") == \"Cancer\" def test_days_to_birthday(): today = date.today() next_birthday = date(today.year, 12, 31) if next_birthday < today: next_birthday = date(today.year + 1, 12, 31) expected_days = (next_birthday - today).days assert days_to_birthday(\"2000-12-31\") == expected_days These tests check the core functionality of our utility functions.","title":"2. Writing Unit Tests"},{"location":"Introduction_git/#3-writing-integration-tests","text":"Now, let's add integration tests for our Flask routes: Add the following code to test_app.py : import pytest from app import app @pytest.fixture def client(): app.config['TESTING'] = True with app.test_client() as client: yield client def test_home_page(client): response = client.get('/') assert response.status_code == 200 assert b\"Welcome to the Birthday App\" in response.data def test_form_submission(client): response = client.post('/', data={ 'name': 'John Doe', 'dob': '1990-01-01' }, follow_redirects=True) assert response.status_code == 200 assert b\"John Doe\" in response.data assert b\"Your age is\" in response.data assert b\"Your zodiac sign is\" in response.data These tests check that our application's routes are working correctly.","title":"3. Writing Integration Tests"},{"location":"Introduction_git/#4-running-the-tests","text":"To run the tests: In your terminal, navigate to your project directory. Run the following command: pytest You should see output indicating which tests passed or failed. In our case you should see that test_form_submission failed can you see why, and how to fix it?","title":"4. Running the Tests"},{"location":"Introduction_git/#5-test-driven-development-adding-a-new-feature","text":"Test-Driven Development (TDD) is a software development approach where tests are written before the actual code. The TDD cycle, often referred to as Red-Green-Refactor, consists of three steps: Red: Write a test that fails. This test describes a desired functionality that doesn't exist yet. Green: Write the minimal amount of code necessary to make the test pass. The focus here is on making the test pass, not on writing perfect code. Refactor: Improve the code without changing its functionality. This step is about cleaning up the code, removing duplication, and ensuring it follows good design principles. The benefits of TDD include: Improved code quality: By thinking about how to test the code before writing it, developers often create more modular, flexible, and easier-to-maintain code. Better understanding of requirements: Writing tests first forces developers to clearly understand what the code should do before implementing it. Built-in regression testing: As features are added, the growing suite of tests helps ensure that new changes don't break existing functionality. Documentation: Tests serve as a form of documentation, showing how the code is expected to behave in various scenarios. Confidence in refactoring: With a comprehensive test suite, developers can refactor code with confidence, knowing that if they break something, a test will fail. Let's practice TDD by adding a new feature to determine if it's the user's birthday today. First, write a test for the new function in test_app.py : from app import is_birthday_today def test_is_birthday_today(): today = date.today() assert is_birthday_today(f\"{today.year}-{today.month:02d}-{today.day:02d}\") == True assert is_birthday_today(\"1990-01-01\") == (date.today().month == 1 and date.today().day == 1) Run the tests. The new test should fail because we haven't implemented the function yet. Now, implement the function in app.py : def is_birthday_today(dob): today = date.today() birth_date = datetime.strptime(dob, \"%Y-%m-%d\").date() return (today.month, today.day) == (birth_date.month, birth_date.day) Run the tests again. They should all pass now. Finally, update your index route to use this new function: @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': name = request.form['name'] dob = request.form['dob'] age = calculate_age(dob) zodiac = get_zodiac_sign(dob) days_to_bday = days_to_birthday(dob) is_birthday = is_birthday_today(dob) lucky_number = get_lucky_number() message = f\"Greetings, {name}! You're {age} years old with the zodiac sign {zodiac}. Your next birthday is in {days_to_bday} days. Your lucky number is {lucky_number}!\" if is_birthday: message += \"Happy Birthday!\" else: message += f\"There are {days_to_bday} days until your next birthday.\" return render_template('result.html', message=message) return render_template('index.html') Add a test for this new route behavior in test_app.py : def test_birthday_today(client): today = date.today() response = client.post('/', data={ 'name': 'John Doe', 'dob': f\"{today.year}-{today.month:02d}-{today.day:02d}\" }, follow_redirects=True) assert b\"Happy Birthday!\" in response.data Run the tests one final time to ensure everything is working.","title":"5. Test-Driven Development: Adding a New Feature"},{"location":"Introduction_git/#stage-7-introduction-to-cicd","text":"Continuous Integration (CI) and Continuous Deployment (CD) are practices in software development that aim to improve the process of building, testing, and releasing software.","title":"Stage 7: Introduction to CI/CD"},{"location":"Introduction_git/#continuous-integration-ci","text":"Continuous Integration is the practice of frequently merging code changes into a shared repository. Each integration is verified by automated builds and tests. The main goals of CI are: Detect and address integration issues early Improve software quality Reduce the time to validate and release new updates With CI, developers integrate their work frequently, usually daily, leading to multiple integrations per day. Each integration triggers automated builds and tests to detect issues quickly.","title":"Continuous Integration (CI)"},{"location":"Introduction_git/#continuous-deployment-cd","text":"Continuous Deployment takes CI one step further. In CD, every change that passes the automated tests is automatically deployed to production. The main benefits of CD are: Faster release cycles Reduced manual processes and human error More frequent user feedback Improved developer productivity CD can also refer to Continuous Delivery, where changes are automatically deployed to a staging environment but require manual approval for production deployment.","title":"Continuous Deployment (CD)"},{"location":"Introduction_git/#why-cicd-is-useful","text":"Faster Bug Detection and Resolution : Issues are caught earlier in the development process, making them easier and less expensive to fix. Improved Collaboration : Frequent integration encourages communication between team members and keeps everyone up to date with changes. Higher Quality Software : Automated testing ensures that tests are run consistently and frequently, catching bugs that might be missed in manual testing. Faster Time to Market : Automating the build, test, and deployment processes reduces the time between writing code and using it in production. Reduced Risk : Smaller, more frequent updates are less risky and easier to roll back if issues occur. Increased Confidence : With a robust CI/CD pipeline, teams can be more confident in the stability and quality of their code. In the following section, we'll implement a basic CI/CD pipeline using GitLab Actions, experiencing firsthand how these practices can improve our development workflow.","title":"Why CI/CD is Useful"},{"location":"Introduction_git/#implementing-cicd-with-gitlab","text":"In this final part, we'll set up a Continuous Integration/Continuous Deployment (CI/CD) pipeline using GitLab Actions. We'll deliberately introduce a failing test, observe it fail both locally and in the CI pipeline, and then fix it.","title":"Implementing CI/CD with GitLab"},{"location":"Introduction_git/#1-setting-up-gitlab-cicd","text":"In your local repository, create a new file named .gitlab-ci.yml in the root directory: touch .gitlab-ci.yml Create a new file .GitLab/workflows/python-app.yml with the following content: image: python:3.8 stages: - test before_script: - python -m pip install --upgrade pip - pip install flask pytest test: stage: test script: - pytest only: - main - merge_requests This GitLab CI/CD configuration does the following: Uses a Python 3.8 Docker image for the CI environment Defines a single stage called \"test\" Installs the necessary dependencies (Flask and pytest) Runs the pytest command to execute the tests Triggers the pipeline on pushes to the main branch and for merge requests Commit and push this new file: git add .gitlab-ci.yml git commit -m \"Add GitLab CI/CD configuration\" git push origin main","title":"1. Setting Up GitLab CI/CD"},{"location":"Introduction_git/#2-introducing-a-failing-test","text":"Let's modify our calculate_age function to introduce a bug, and update its test to catch this bug. In app.py , change the calculate_age function: def calculate_age(dob): today = date.today() birth_date = datetime.strptime(dob, \"%Y-%m-%d\").date() age = today.year - birth_date.year # Introduce a bug: forget to check if birthday has occurred this year return age # This might be off by one year In test_app.py , update the test_calculate_age function: def test_calculate_age(): today = date.today() assert calculate_age(f\"{today.year-30}-{today.month:02d}-{today.day:02d}\") == 30 assert calculate_age(f\"{today.year-30}-{today.month:02d}-{today.day+1:02d}\") == 29 # This will fail","title":"2. Introducing a Failing Test"},{"location":"Introduction_git/#3-running-tests-locally","text":"Run the tests locally to see the failure: pytest You should see that the second assertion in test_calculate_age fails.","title":"3. Running Tests Locally"},{"location":"Introduction_git/#4-pushing-to-gitlab-and-observing-ci-failure","text":"Commit and push these changes: git add app.py test_app.py git commit -m \"Update calculate_age function and its test\" git push origin main Go to your GitLab repository, click on the \"Build/Pipelines\" tab, and you should see the pipeline running. It will fail due to the failing test. Because of that failure, the code won't be deployed to the production environment. You can think of the pipeline as a way to ensure that the code is working as expected before it is deployed to the production environment.","title":"4. Pushing to GitLab and Observing CI Failure"},{"location":"Introduction_git/#5-fixing-the-bug","text":"Now, let's fix the bug in the calculate_age function: In app.py , correct the calculate_age function: def calculate_age(dob): today = date.today() birth_date = datetime.strptime(dob, \"%Y-%m-%d\").date() age = today.year - birth_date.year # Check if birthday has occurred this year if today < date(today.year, birth_date.month, birth_date.day): age -= 1 return age Commit and push the fix: git add app.py git commit -m \"Fix calculate_age function\" git push origin main Go back to the GitLab tab and watch the new workflow run. It should pass all tests now. By following these steps, you've implemented a basic CI/CD pipeline using GitLab. This pipeline will automatically run your tests whenever you push changes to the repository, helping you catch issues early and ensure the quality of your code.","title":"5. Fixing the Bug"}]}